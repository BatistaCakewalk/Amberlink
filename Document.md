ðŸ“„ Amberlink: Technical Specification
Amberlink is a high-performance, multi-paradigm programming language designed to bridge the gap between the safety of Java and the raw power of C++. It utilizes a unique Dual-Backend approach, allowing code to run either on a dedicated Virtual Machine (AVM) or as a native binary.
1. System Architecture
Amberlink is split into two primary components to ensure memory safety and execution speed:
â€¢ The Brain (Amber-Core): Built in Rust. It handles the frontend tasks: Lexing, Parsing, Semantic Analysis, and Bytecode Generation. Using Rust ensures the compiler is immune to memory-related crashes.
â€¢ The Body (Amber-VM / AVM): Built in C++. A high-performance, stack-based virtual machine featuring a custom Mark-and-Sweep Garbage Collector and a lean object header system.
2. The Compilation Pipeline
Amberlink uses a Two-Pass Compilation strategy to solve the "Forward Declaration" problem found in older languages like C++.
1. Pass 1 (Discovery): The compiler scans the .amb source file to identify all function signatures, class definitions, and global variables. It populates the Symbol Table.
2. Pass 2 (Validation & Emission): The compiler verifies the logic and types. If successful, the Emitter generates a highly optimized binary file with the .amc (Amber Compiled) extension.
3. Language Design Philosophy
Amberlink is designed to be cleaner and more stable than Java:
â€¢ New-line Based: No semicolons required. The parser uses significant newlines to end statements.
â€¢ Null-Safety: All types are non-nullable by default. Optional types must be explicitly declared (e.g., Int?).
â€¢ Multi-Paradigm: Supports both Object-Oriented Programming (OOP) via Classes and Functional Programming via standalone functions.
4. The AVM Bytecode Format (.amc)
The binary format is designed for(havent finished this psrt yet)


5. Memory Management (The GC)
Unlike the heavy, unpredictable JVM Garbage Collector, the Amber-VM uses a Lean Header system:
â€¢ Object Header: Only 8 bytes (Type Tag + Mark Bit).
â€¢ GC Strategy: A generational Mark-and-Sweep collector that can be manually "hinted" by the developer to pause during high-performance tasks.


6. Project Structure
Amberlink/
â”œâ”€â”€ amber-core/    # Rust: Lexer, Parser, Emitter
â”œâ”€â”€ amber-vm/      # C++: Interpreter, GC, Loader
â”œâ”€â”€ bin/           # Final tool binaries (ambc, avm)
â”œâ”€â”€ stdlib/        # Standard Amberlink libraries
â””â”€â”€ scripts/       # Python build automation


7. Build and Run
To build the entire ecosystem from source:

1. Ensure you have Rust (Cargo), C++ (CMake), and Python 3 installed.

2. Run the master build script:

python scripts/build_all.py


3. Compile an Amber file:

./bin/ambc main.amb


4. Run the generated bytecode:

./bin/avm output.amc
