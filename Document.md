ðŸ“„ Amberlink: Technical Specification
Amberlink is a high-performance, multi-paradigm programming language designed to bridge the gap between the safety of Java and the raw power of C++. It utilizes a unique Dual-Backend approach, allowing code to run either on a dedicated Virtual Machine (AVM) or as a native binary.
1. System Architecture
Amberlink is split into two primary components to ensure memory safety and execution speed:
â€¢ The Brain (Amber-Core): Built in Rust. It handles the frontend tasks: Lexing, Parsing, Semantic Analysis, and Bytecode Generation. Using Rust ensures the compiler is immune to memory-related crashes.
â€¢ The Body (Amber-VM / AVM): Built in C++. A high-performance, stack-based virtual machine featuring a custom Mark-and-Sweep Garbage Collector and a lean object header system.
2. The Compilation Pipeline
Amberlink uses a Two-Pass Compilation strategy to solve the "Forward Declaration" problem found in older languages like C++.
1. Pass 1 (Discovery): The compiler scans the .amb source file to identify all function signatures, class definitions, and global variables. It populates the Symbol Table.
2. Pass 2 (Validation & Emission): The compiler verifies the logic and types. If successful, the Emitter generates a highly optimized binary file with the .amc (Amber Compiled) extension.
3. Language Design Philosophy
Amberlink is designed to be cleaner and more stable than Java:
â€¢ New-line Based: No semicolons required. The parser uses significant newlines to end statements.
â€¢ Null-Safety: All types are non-nullable by default. Optional types must be explicitly declared (e.g., Int?).
â€¢ Multi-Paradigm: Supports both Object-Oriented Programming (OOP) via Classes and Functional Programming via standalone functions.
4. The AVM Bytecode Format (.amc)
The binary format is designed for(havent finished this psrt yet)


5. Memory Management (The GC)
Unlike the heavy, unpredictable JVM Garbage Collector, the Amber-VM uses a Lean Header system:
â€¢ Object Header: Only 8 bytes (Type Tag + Mark Bit).
â€¢ GC Strategy: A generational Mark-and-Sweep collector that can be manually "hinted" by the developer to pause during high-performance tasks.


6. Project Structure
Amberlink/
â”œâ”€â”€ amber-core/    # Rust: Lexer, Parser, Emitter
â”œâ”€â”€ amber-vm/      # C++: Interpreter, GC, Loader
â”œâ”€â”€ bin/           # Final tool binaries (ambc, avm)
â”œâ”€â”€ stdlib/        # Standard Amberlink libraries
â””â”€â”€ scripts/       # Python build automation


7. Build and Run
To build the entire ecosystem from source:

1. Ensure you have Rust (Cargo), C++ (CMake), and Python 3 installed.

2. Run the master build script:

python scripts/build_all.py


3. Compile an Amber file:

./bin/ambc main.amb


4. Run the generated bytecode:

./bin/avm output.amc


8. Development Roadmap
The development of Amberlink is planned in distinct phases, each building upon the last to create a robust and feature-rich language.

### Phase 1: Core Language Features (The "Usable" Milestone)
This phase focuses on implementing the fundamental building blocks required to write simple, yet complete, programs.
1.  **Control Flow:** Implement `if/else` statements and `while` loops. This requires adding jump opcodes (`JUMP`, `JUMP_IF_FALSE`) to the VM and the corresponding logic in the compiler's Emitter.
2.  **Full Function Support:** Parse function bodies (`{...}`), parameters, and `return` statements. Implement a proper call stack in the VM with `CALL` and `RETURN` opcodes.
3.  **Scoping:** Differentiate between global and local variables to enable proper encapsulation and recursion.

### Phase 2: Data Structures & Memory (The "Robust" Milestone)
This phase moves beyond simple numbers and introduces the ability to manage more complex data.
1.  **String & Constant Pool:** Implement heap-allocated strings and a "constant pool" in the bytecode to efficiently store and reuse literals.
2.  **GC Root Scanning:** Fully implement the Garbage Collector by teaching it to scan the VM's stack and global variables for "roots" to determine which objects are still in use.
3.  **Arrays:** Introduce a built-in array/list type as the first user-creatable, heap-allocated collection.

### Phase 3: Object-Oriented Programming (The "Modern" Milestone)
This phase brings Amberlink closer to its goal of being a modern, Java-like language.
1.  **Classes & Instances:** Implement `class` definitions, fields, and object instantiation (`new MyClass()`).
2.  **Methods & `this`:** Allow methods to be defined within classes and implement the `this` keyword to refer to the current instance.
3.  **Inheritance:** Implement single inheritance for classes, allowing for code reuse and polymorphism.

### Phase 4: Ecosystem & Tooling (The "Mature" Milestone)
This phase focuses on building the tools and libraries that make a language productive and enjoyable to use.
1.  **Standard Library:** Create a foundational `stdlib` with modules for I/O, collections (e.g., HashMap), and string utilities.
2.  **Developer Tooling:**
    *   **Language Server (LSP):** Provide IDE support for features like autocompletion and error highlighting.
    *   **Debugger:** Create a tool to step through Amberlink code, inspect variables, and analyze the stack.
    *   **Package Manager:** Develop a system for sharing and managing third-party Amberlink libraries.
